---
# This config uses the HMC5883L, a triple-axis magnetometer, to read your water meter or gas meter.

substitutions:
  # water or gas
  device_class: 'water'

  # mdi:water or mdi:meter-gas
  device_icon: 'mdi:water'

  # For water one of: CCF, ft³, gal, L, m³
  # For gas one of: CCF, ft³, m³
  volume_unit: 'L'

  i2c_scl: GPIO5  # D1
  i2c_sda: GPIO4  # D2

  # Set these only if you have connected two HMC5883L to one device, see esphome-two-meters.yaml
  prefix_name: ''
  prefix_id: ''

  hmc5883l_update_interval: '5ms'

  volume_per_half_rotation_initial_value: '0.01008156'
  flow_update_interval_seconds: '10'

esphome:
  min_version: "2024.4.0"
  on_boot:
    then:
      - lambda: App.set_loop_interval(0);

logger:
  logs:
    hmc5883l: INFO

api:
  services:
    - service: ${prefix_id}set_total
      variables:
        new_total: float
      then:
        - globals.set:
            id: ${prefix_id}half_rotations_total
            value: !lambda 'return new_total / id(${prefix_id}volume_per_half_rotation).state;'

globals:
  - id: ${prefix_id}half_rotations_total
    type: long
    restore_value: yes
    initial_value: '0'
  - id: ${prefix_id}half_rotations_flow
    type: long
    restore_value: no
    initial_value: '0'
  - id: ${prefix_id}axis_value_high
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${prefix_id}calibrating
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${prefix_id}calibrating_axis_x_min
    type: float
    restore_value: no
  - id: ${prefix_id}calibrating_axis_x_max
    type: float
    restore_value: no
  - id: ${prefix_id}calibrating_axis_y_min
    type: float
    restore_value: no
  - id: ${prefix_id}calibrating_axis_y_max
    type: float
    restore_value: no
  - id: ${prefix_id}calibrating_axis_z_min
    type: float
    restore_value: no
  - id: ${prefix_id}calibrating_axis_z_max
    type: float
    restore_value: no

number:
  - platform: template
    id: ${prefix_id}volume_per_half_rotation
    name: ${prefix_name}Volume per half rotation
    entity_category: config
    mode: box
    min_value: 0
    max_value: 9999999
    step: 0.000000001
    initial_value: ${volume_per_half_rotation_initial_value}
    update_interval: never
    restore_value: true
    optimistic: true
    unit_of_measurement: ${volume_unit}

  - platform: template
    id: ${prefix_id}temperature_offset
    name: ${prefix_name}Temperature Offset
    unit_of_measurement: '°C'
    min_value: -100
    max_value: 100
    step: 0.1
    mode: box
    update_interval: never
    optimistic: true
    restore_value: true
    initial_value: 33
    icon: 'mdi:thermometer'
    entity_category: config

  - platform: template
    id: ${prefix_id}threshold_lower
    name: ${prefix_name}Threshold lower
    entity_category: config
    mode: box
    min_value: -9999
    max_value: 9999
    step: 0.1
    initial_value: -9999
    update_interval: never
    restore_value: true
    optimistic: true
    unit_of_measurement: µT

  - platform: template
    id: ${prefix_id}threshold_upper
    name: ${prefix_name}Threshold upper
    entity_category: config
    mode: box
    min_value: -9999
    max_value: 9999
    step: 0.1
    initial_value: 9999
    update_interval: never
    restore_value: true
    optimistic: true
    unit_of_measurement: µT

  - platform: template
    id: ${prefix_id}calibration_seconds
    name: ${prefix_name}Calibration time
    entity_category: config
    icon: mdi:timer
    mode: box
    min_value: 1
    max_value: 999
    step: 1
    initial_value: 5
    update_interval: never
    restore_value: true
    optimistic: true
    unit_of_measurement: s

select:
  - platform: template
    id: ${prefix_id}axis
    name: ${prefix_name}Axis
    entity_category: config
    options:
      - x
      - y
      - z
      - None
    initial_option: None
    update_interval: never
    restore_value: true
    optimistic: true

button:
  - platform: template
    id: ${prefix_id}calibrate_button
    name: ${prefix_name}Calibrate axis
    entity_category: config
    on_press:
      - lambda: |-
          ESP_LOGI("calibration", "Starting calibration. Make sure ${device_class} is running");
          id(${prefix_id}calibrating_axis_x_min) = std::numeric_limits<float>::max();
          id(${prefix_id}calibrating_axis_x_max) = std::numeric_limits<float>::lowest();
          id(${prefix_id}calibrating_axis_y_min) = std::numeric_limits<float>::max();
          id(${prefix_id}calibrating_axis_y_max) = std::numeric_limits<float>::lowest();
          id(${prefix_id}calibrating_axis_z_min) = std::numeric_limits<float>::max();
          id(${prefix_id}calibrating_axis_z_max) = std::numeric_limits<float>::lowest();
          id(${prefix_id}calibrating) = true;
      - delay: !lambda return id(${prefix_id}calibration_seconds).state * 1000;
      - lambda: |-
          id(${prefix_id}calibrating) = false;
          float x_range = id(${prefix_id}calibrating_axis_x_max) - id(${prefix_id}calibrating_axis_x_min);
          float y_range = id(${prefix_id}calibrating_axis_y_max) - id(${prefix_id}calibrating_axis_y_min);
          float z_range = id(${prefix_id}calibrating_axis_z_max) - id(${prefix_id}calibrating_axis_z_min);
          if (x_range < 0) {
            ESP_LOGW("${prefix_id}calibration", "Didn't get any values for x");
          } else {
            ESP_LOGI("${prefix_id}calibration", "x ranged from %.2f to %.2f",
                     id(${prefix_id}calibrating_axis_x_min), id(${prefix_id}calibrating_axis_x_max));
          }
          if (y_range < 0) {
            ESP_LOGW("${prefix_id}calibration", "Didn't get any values for y");
          } else {
            ESP_LOGI("${prefix_id}calibration", "y ranged from %.2f to %.2f",
                     id(${prefix_id}calibrating_axis_y_min), id(${prefix_id}calibrating_axis_y_max));
          }
          if (z_range < 0) {
            ESP_LOGW("${prefix_id}calibration", "Didn't get any values for z");
          } else {
            ESP_LOGI("${prefix_id}calibration", "z ranged from %.2f to %.2f",
                     id(${prefix_id}calibrating_axis_z_min), id(${prefix_id}calibrating_axis_z_max));
          }
          std::string axis_with_largest_range;
          float min, max;
          if (x_range > 20 && x_range > y_range && x_range > z_range) {
            axis_with_largest_range = "x";
            min = id(${prefix_id}calibrating_axis_x_min);
            max = id(${prefix_id}calibrating_axis_x_max);
          } else if (y_range > 20 && y_range > x_range && y_range > z_range) {
            axis_with_largest_range = "y";
            min = id(${prefix_id}calibrating_axis_y_min);
            max = id(${prefix_id}calibrating_axis_y_max);
          } else if (z_range > 20 && z_range > x_range && z_range > y_range) {
            axis_with_largest_range = "z";
            min = id(${prefix_id}calibrating_axis_z_min);
            max = id(${prefix_id}calibrating_axis_z_max);
          } else {
            ESP_LOGE("${prefix_id}calibration", "No axis had a range of more than 20 uT. Try again with a different calibration time.");
            return;
          }
          ESP_LOGI("${prefix_id}calibration", "Selecting %s axis with min %.2f and max %.2f",
                   axis_with_largest_range.c_str(), min, max);
          id(${prefix_id}axis).publish_state(axis_with_largest_range);
          id(${prefix_id}threshold_lower).publish_state(min + 0.20 * (max - min));
          id(${prefix_id}threshold_upper).publish_state(min + 0.80 * (max - min));

sensor:
  - platform: hmc5883l
    id: ${prefix_id}hmc5883l_sensor
    address: 0x1E
    update_interval: ${hmc5883l_update_interval}
    x_raw:
      name: ${prefix_name}HMC5883L x raw
      icon: mdi:magnet
      entity_category: diagnostic
      filters:
        - filter_out: 0.00
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
    y_raw:
      name: ${prefix_name}HMC5883L y raw
      icon: mdi:magnet
      entity_category: diagnostic
      filters:
        - filter_out: 0.00
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
    z_raw:
      name: ${prefix_name}HMC5883L z raw
      icon: mdi:magnet
      entity_category: diagnostic
      filters:
        - filter_out: 0.00
        - sliding_window_moving_average:
            window_size: 5
            send_every: 5
    temperature:
      name: ${prefix_name}HMC5883L temperature
      entity_category: diagnostic
      filters:
        - offset: !lambda return id(${prefix_id}temperature_offset).state;

text_sensor:
  - platform: version
    name: ${prefix_name}ESPHome version

binary_sensor:
  - platform: status
    name: ${prefix_name}Status

interval:
  - interval: 1s
    then:
      if:
        condition:
          lambda: return id(${prefix_id}calibrating);
        then:
          - sensor.hmc5883l_x_raw.publish:
              id: ${prefix_id}hmc5883l_sensor
          - sensor.hmc5883l_y_raw.publish:
              id: ${prefix_id}hmc5883l_sensor
          - sensor.hmc5883l_z_raw.publish:
              id: ${prefix_id}hmc5883l_sensor
          - lambda: |-
              id(${prefix_id}calibrating_axis_x_min) = std::min(id(${prefix_id}calibrating_axis_x_min), id(${prefix_id}hmc5883l_sensor).state.x);
              id(${prefix_id}calibrating_axis_x_max) = std::max(id(${prefix_id}calibrating_axis_x_max), id(${prefix_id}hmc5883l_sensor).state.x);
              id(${prefix_id}calibrating_axis_y_min) = std::min(id(${prefix_id}calibrating_axis_y_min), id(${prefix_id}hmc5883l_sensor).state.y);
              id(${prefix_id}calibrating_axis_y_max) = std::max(id(${prefix_id}calibrating_axis_y_max), id(${prefix_id}hmc5883l_sensor).state.y);
              id(${prefix_id}calibrating_axis_z_min) = std::min(id(${prefix_id}calibrating_axis_z_min), id(${prefix_id}hmc5883l_sensor).state.z);
              id(${prefix_id}calibrating_axis_z_max) = std::max(id(${prefix_id}calibrating_axis_z_max), id(${prefix_id}hmc5883l_sensor).state.z);
